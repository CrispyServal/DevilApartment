# 技术笔记

## 关于像素大小和渲染效率

经截图研究，noita满屏显示的像素数约为427\*240。在我的4k显示器上，每个像素是9\*9大小。

其ui分辨率更高，每个像素是4\*4大小。

这样的话，在不缩小相机的前提下，我们的渲染效率（指将rust的数据阵列渲染到屏幕上的过程）是足够的。

之后瓶颈只会出现在逻辑效率上。不更新区块我们不刷新texture，效率还会再提高。

### 当前方案及原因

本来直接用一张Image，配合一个ImageTexture，渲染到一个Sprite上。方便实现。

但是遇到问题是：Image可以选择性更新，效率可以。但是ImageTexture只能从整个Image中获取数据。使效率大大降低，在我的机器上只能跑5帧。

因此现在使用256大小的块来拼接，这样只需要在特定范围内进行ImageTexute的刷新。当前实验16块同时更新可以到55帧。

### 再分析

假设我们使用noita的像素大小。那屏幕可见范围最多只有6块需要刷新显示。
这个6是这么来的：

横向最多看见 `math.ceil(427 / 256) + 1 = 3`
纵向最多看见 `math.ceil(240 / 256) + 1 = 2`

假设我们只更新6块渲染，fps可以达到140以上。
